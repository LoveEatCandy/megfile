{
  "smart_symlink": "Create a symbolic link pointing to src_path named path.\n\n:param dst_path: Desination path\n:param src_path: Source path",
  "smart_readlink": "Return a string representing the path to which the symbolic link points.\n:param path: Path to be read\n:returns: Return a string representing the path to which the symbolic link points.",
  "smart_isdir": "Test if a file path or an s3 url is directory\n\n:param path: Path to be tested\n:returns: True if path is directory, else False",
  "smart_isfile": "Test if a file path or an s3 url is file\n\n:param path: Path to be tested\n:returns: True if path is file, else False",
  "smart_access": "Test if path has access permission described by mode\n\n:param path: Path to be tested\n:param mode: Access mode(Access.READ, Access.WRITE, Access.BUCKETREAD, Access.BUCKETWRITE)\n:returns: bool, if the path has read/write access.",
  "smart_exists": "Test if path or s3_url exists\n\n:param path: Path to be tested\n:returns: True if path eixsts, else False",
  "smart_listdir": "Get all contents of given s3_url or file path. The result is in acsending alphabetical order.\n\n:param path: Given path\n:returns: All contents of given s3_url or file path in acsending alphabetical order.\n:raises: FileNotFoundError, NotADirectoryError",
  "smart_scandir": "Get all content of given s3_url or file path.\n\n:param path: Given path\n:returns: An iterator contains all contents have prefix path\n:raises: FileNotFoundError, NotADirectoryError",
  "smart_getsize": "Get file size on the given s3_url or file path (in bytes).\nIf the path in a directory, return the sum of all file size in it, including file in subdirectories (if exist).\nThe result excludes the size of directory itself. In other words, return 0 Byte on an empty directory path.\n\n:param path: Given path\n:returns: File size\n:raises: FileNotFoundError",
  "smart_getmtime": "Get last-modified time of the file on the given s3_url or file path (in Unix timestamp format).\nIf the path is an existent directory, return the latest modified time of all file in it. The mtime of empty directory is 1970-01-01 00:00:00\n\n:param path: Given path\n:returns: Last-modified time\n:raises: FileNotFoundError",
  "smart_stat": "Get StatResult of s3_url or file path\n\n:param path: Given path\n:returns: StatResult\n:raises: FileNotFoundError",
  "smart_remove": "Remove the file or directory on s3 or fs, `s3://` and `s3://bucket` are not permitted to remove\n\n:param path: Given path\n:param missing_ok: if False and target file/directory not exists, raise FileNotFoundError\n:raises: PermissionError, FileNotFoundError",
  "smart_unlink": "Remove the file on s3 or fs\n\n:param path: Given path\n:param missing_ok: if False and target file not exists, raise FileNotFoundError\n:raises: PermissionError, FileNotFoundError, IsADirectoryError",
  "smart_makedirs": "Create a directory if is on fs.\nIf on s3, it actually check if target exists, and check if bucket has WRITE access\n\n:param path: Given path\n:param exist_ok: if False and target directory not exists, raise FileNotFoundError\n:raises: PermissionError, FileExistsError",
  "smart_open": "Open a file on the path\n\n.. note ::\n\nOn fs, the difference between this function and ``io.open`` is that this function create directories automatically, instead of raising FileNotFoundError\n\nCurrently, supported protocols are:\n\n1. s3:      \"s3://<bucket>/<key>\"\n\n2. http(s): http(s) url\n\n3. stdio:   \"stdio://-\"\n\n4. FS file: Besides above mentioned protocols, other path are considered fs path\n\nHere are a few examples: ::\n\n>>> import cv2\n>>> import numpy as np\n>>> raw = smart_open('https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=2275743969,3715493841&fm=26&gp=0.jpg').read()\n>>> img = cv2.imdecode(np.frombuffer(raw, np.uint8), cv2.IMREAD_ANYDEPTH | cv2.IMREAD_COLOR)\n\n:param path: Given path\n:param mode: Mode to open file, supports r'[rwa][tb]?\\+?'\n:param s3_open_func: Function used to open s3_url. Require the function includes 2 necessary parameters, file path and mode\n:returns: File-Like object\n:raises: FileNotFoundError, IsADirectoryError, ValueError",
  "smart_walk": "Generate the file names in a directory tree by walking the tree top-down.\nFor each directory in the tree rooted at directory path (including path itself),\nit yields a 3-tuple (root, dirs, files).\n\nroot: a string of current path\ndirs: name list of subdirectories (excluding '.' and '..' if they exist) in 'root'. The list is sorted by ascending alphabetical order\nfiles: name list of non-directory files (link is regarded as file) in 'root'. The list is sorted by ascending alphabetical order\n\nIf path not exists, return an empty generator\nIf path is a file, return an empty generator\nIf try to apply walk() on unsupported path, raise UnsupportedError\n\n:param path: Given path\n:raises: UnsupportedError\n:returns: A 3-tuple generator",
  "smart_scan": "Iteratively traverse only files in given directory, in alphabetical order.\nEvery iteration on generator yields a path string.\n\nIf path is a file path, yields the file only\nIf path is a non-existent path, return an empty generator\nIf path is a bucket path, return all file paths in the bucket\n\n:param path: Given path\n:param missing_ok: If False and there's no file in the directory, raise FileNotFoundError\n:raises: UnsupportedError\n:returns: A file path generator",
  "smart_scan_stat": "Iteratively traverse only files in given directory, in alphabetical order.\nEvery iteration on generator yields a tuple of path string and file stat\n\n:param path: Given path\n:param missing_ok: If False and there's no file in the directory, raise FileNotFoundError\n:raises: UnsupportedError\n:returns: A file path generator",
  "smart_load_from": "Read all content in binary on specified path and write into memory\n\nUser should close the BinaryIO manually\n\n:param path: Specified path\n:returns: BinaryIO",
  "smart_abspath": "Return the absolute path of given path\n\n:param path: Given path\n:returns: Absolute path of given path",
  "smart_relpath": "Return the relative path of given path\n\n:param path: Given path\n:param start: Given start directory\n:returns: Relative path from start",
  "smart_ismount": "Test whether a path is a mount point\n\n:param path: Given path\n:returns: True if a path is a mount point, else False"
}